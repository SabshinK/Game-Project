---- SPRINT FOUR ----

READABILTY REVIEW:

Author of the code review: Aadya Jain
Date of the code review: 04/08/22
Sprint number: 4
Name of the .cs file being reviewed: Bomb.cs
Author of the .cs file being reviewed: Sebastian King
Number of minutes taken to complete the review: 20
The code is very easy to read with consistent variable and function names. While there is a magic number for the bomb's lifespan, it can be fixed with the UtilityClass. The code also has many comments which makes it easy to understand the code. 
MAINTAINABILITY:

Author of the code review: Aadya Jain
Date of the code review: 04/08/22
Sprint number: 4
Name of the .cs file being reviewed: ItemScroller.cs
Author of the .cs file being reviewed: Anooj Deshpande
Number of minutes taken to complete Review: 30
Specific comments on code quality
One change I would make: 
The author of the code makes good design choices for maintainability. Once change that I would make would be to create a "FeedItemList" that is called by the public constructor to populate the item list with the items. Currently, the code adds the items in the public constructor, but if we add more items, then it would be a little hard to manage. If there is a function that adds all the items for us, it wouldn't matter how many items we had, it would be be better for the public constructor to do one job and modularize.


---- SPRINT THREE ----

READABILTY REVIEW:

Author of the code review: Aadya Jain
Date of the code review: 03/10/22
Sprint number: 3
Name of the .cs file being reviewed: LevelLoader.cs
Author of the .cs file being reviewed: Sebastian King
Number of minutes taken to complete the review: 30
At first glance, the code is easy to follow with consistent naming conventions with the usage of camel case, and there is consistent grouping and spacing to follow along with the blocks of code. The variables are also self-explanatory and good descriptors of their goal. There are comments to make it easy to understand the code, particularly with LoadObjectData function which uses multiple variables and handles constructors. There are a few magic numbers and line 100 is long enough to be cut into two lines for easier readbility. To effect, the variables and functions are named well and the spacing and grouping allows for an easier read. Some of the lines are a little longer. It was also good choice to have the list of types of enemies and objects at the very end instead of in the middle as well. 

MAINTAINABILITY:

Author of the code review: Aadya Jain
Date of the code review: 03/22
Sprint number: 3
Name of the .cs file being reviewed: CollisionResolution.cs
Author of the .cs file being reviewed: Rachel Watters
Specific comments on code quality
One change I would make: 
The author of the code makes a good design choice for maintainability with the dictionary which holds the direction, objects involved in the collision and the type of collision resolution they would require. Unfortunately, this does cause a lot of similar code to handle the different types as well as the giant list in the end to add every single type of enemy or player that could be taking damage. One change could be having an EnemyTakeDamageCommand rather than specific types which would have a list of enemies to loop through and match which type of enemy and then the damage is handled appropriately. This would reduce the work later in terms of maintainability if we add more types of collideable objects. The comments also do highlight that the FallBackCommand would work and implementing that would be a good idea since we can access the directions and change the boolean for the direction as needed.

---- SPRINT TWO ----

READABILTY REVIEW:

Author of the code review: Aadya Jain
Date of the code review: 02/19
Sprint number: 2
Name of the .cs file being reviewed: Arrow.cs
Author of the .cs file being reviewed: Anooj Deshpande
Number of minutes taken to complete the review: 25

The code in the Arrow.cs file had consistent variable naming convention using camel case with lifeSpan, userDirection, moveFactor. moveFactor is also a variable that has been used throughout all of the projectiles to describe the factor of the speed that the projectiles are moving. Each if block is spaced apart and there are easy to follow comments to explain the code. I would also group the initial variable names based on the type and interfaces. Currently, it's in the order of Vector, float, int, spritebatch, ISprite, boolean. I would probably group primitive types together first, then the vector, and finally the spritebatch and ISprite later. Same thing with the constructor where setting position to this.position is disconnected and far away from setting spritebatch and userDirection. Overall, this is a very readable code.

MAINTAINABILITY:

Author of the code review: Aadya Jain
Date of the code review: 02/19
Sprint number: 2
Name of the .cs file being reviewed: SwordBeam.cs
Author of the .cs file being reviewed: Anooj Deshpande
Specific comments on code quality
One change I would make: 
The first thing that I noticed about the code was the fact that Interfaces.ISprite sprite line which was used instead of ISprite sprite and then referencing in the top with 'using Game_Project.Interfaces.' The userDirection is public, but I'm not sure that if it should since other classes shouldn't be able to change Sword Beam's direction. It would also be important to note that moveFactor is currently using a magic number which we would need to remove for later sprints. Another suggestion would be using a private string animationToCreate which would be set to 'swordBeamRight' or 'swordBeamLeft' in the if block. Then, at the end of the if-else block, the createSprite method can be used with animationToCreate sprite = Sprites.SpriteFactory.Instance.CreateSprite(animationToCreate) to help reduce similar code.. 

